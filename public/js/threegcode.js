/*
    Based on code from:  John Lauer, Todd Fleming
    -- changes by AUTHOR: Peter van der Walt
*/
var inflateGrp, fileParentGroup, fileParentGroupOriginal, fileObjectOriginal, fileGroup, svgPath, fileInflatePath, i, il, y, yl, shape, lines, line;
var options = {};

$(document).ready(function() {

    $('#generategcode').on('click', function() { // DXF job Params to MC
        if (typeof(fileObject) == 'undefined') {
            printLog('No file loaded. do, File -> Open, first!', errorcolor)
        };
        // Lets get the machine specific Gcode from the settings Modal (:
        var startgcode = document.getElementById('startgcode').value;
        var laseron = document.getElementById('laseron').value;
        var laseroff = document.getElementById('laseroff').value;
        var lasermultiply = document.getElementById('lasermultiply').value;
        var homingseq = document.getElementById('homingseq').value;
        var endgcode = document.getElementById('endgcode').value;
        // Remove old Gcode
        document.getElementById('gcodepreview').value = "";
        lineObjects = null;
        lineObjects = new THREE.Object3D();
        var total = scene.children.length
        for (var j = 5; j < total; j++) {
          console.log('Removed ', scene.children[5].name);
          scene.remove(scene.children[5]);
        }
        for (var j = 0; j < objectsInScene.length; j++) {
          console.log('added object ' + j)
          scene.add(objectsInScene[j]);
        }
        var g = ";Gcode generated by Laserweb Three2Gcode;\n";
        if (startgcode) {
            g += startgcode
            g += '\n'
        } else {
            g += "G21 ;mm\n";
            g += 'G90\n';
        };
        scene.updateMatrixWorld();
        pwr = [];
        cutSpeed = [];
        for (j = 0; j < objectsInScene.length; j++) {
            printLog('Processing ' + objectsInScene[j].name, msgcolor)
            if (objectsInScene[j].name != 'object') {
              if (objectsInScene[j].type == "Mesh") {
                console.log('Object '+j+' is a Raster')
                runRaster(j)
              } else {
                console.log('Object '+j+' is a Vector')

                var cutSpeed0 = parseFloat( $("#speed"+(j)).val() ) * 60;
                var pwr0 = parseFloat( $("#power"+(j)).val() );
                rapidSpeed = parseFloat(document.getElementById('rapidspeed').value) * 60;
                g += "; \n";
                g += "; "+objectsInScene[j].name + "\n";
                g += "; \n";
                if (objectsInScene[j].userData.inflated) {
                  g += generateGcode(objectsInScene[j].userData.inflated, cutSpeed0, pwr0, rapidSpeed, laseron, laseroff);
                } else {
                  g += generateGcode(objectsInScene[j], cutSpeed0, pwr0, rapidSpeed, laseron, laseroff);
                }

              }
            }
        }
        if (endgcode) {
            g += endgcode
            g += '\n'
            g += ";End of file\n";
        } else {
            g += ";End of file\n";
        };
        document.getElementById("gcodepreview").value = g;
        openGCodeFromText();
        scene.remove(inflateGrp);
        printLog('Gcode Generated', successcolor);
        $('#gcode-menu').click();
    });
});

function generateGcode(threeGroup, cutSpeed, laserPwr, rapidSpeed, laseron, laseroff) {

    var laserPwrVal = 0.0;
    console.log('inside generateGcode')
    console.log('Group', threeGroup);
    console.log('CutSpeed', cutSpeed);
    console.log('RapidSpeed', rapidSpeed);
    console.log('Laser Power %', laserPwr);
    var lasermultiply = $('#lasermultiply').val();
    console.log('Laser Multiplier', lasermultiply);

    if (lasermultiply <= 1) {
        var laserPwrVal = laserPwr / 100;
        laserPwrVal = parseFloat(laserPwrVal).toFixed(2);
    } else {
        var laserPwrVal = laserPwr * (lasermultiply / 100);
        laserPwrVal = laserPwrVal.toFixed(0);
    }
    console.log('Laser Power Value', laserPwrVal, ' type of ', typeof(laserPwrVal));

    var g = "";
    // get the THREE.Group() that is the txt3d

    var grp = threeGroup;
    var txtGrp = threeGroup;
    var that = this;
    var isLaserOn = false;
    var isAtClearanceHeight = false;
    var isFeedrateSpecifiedAlready = false;
    var isSeekrateSpecifiedAlready = false;
    var subj_paths = [];
    var subj_path2 = [];
    console.log(txtGrp);
    console.log(rapidSpeed)
    console.log(cutSpeed);

    txtGrp.traverse(function(child) {
        console.log(child);
        if (child.type == "Line") {
            // let's create gcode for all points in line
            for (i = 0; i < child.geometry.vertices.length; i++) {

                // Convert to World Coordinates
                var localPt = child.geometry.vertices[i];
                var worldPt = grp.localToWorld(localPt.clone());
                if (stl) {
                    var xpos = (parseFloat(worldPt.x.toFixed(3)) + (parseFloat(laserxmax) / 2) + child.parent.position.x).toFixed(3);
                    var ypos = (parseFloat(worldPt.y.toFixed(3)) + (parseFloat(laserymax) / 2) + child.parent.position.y).toFixed(3);
                } else if (yflip == true && !inflateGrp) {
                    var xpos = (parseFloat(worldPt.x.toFixed(3)) + (parseFloat(laserxmax) / 2)).toFixed(3);
                    var ypos = (-1 * parseFloat(worldPt.y.toFixed(3)) + (parseFloat(laserymax) / 2)).toFixed(3);
                } else {
                    var xpos = (parseFloat(worldPt.x.toFixed(3)) + (parseFloat(laserxmax) / 2)).toFixed(3);
                    var ypos = (parseFloat(worldPt.y.toFixed(3)) + (parseFloat(laserymax) / 2)).toFixed(3);
                };
                // First Move To
                if (i == 0) {
                    // first point in line where we start lasering/milling
                    var seekrate;
                    if (isSeekrateSpecifiedAlready) {
                        seekrate = "";
                    } else {
                        console.log('Rapid Speed: ', rapidSpeed);
                        if (rapidSpeed) {
                            seekrate = " F" + rapidSpeed;
                            isSeekrateSpecifiedAlready = true;
                        } else {
                            seekrate = "";
                        }

                    }
                    g += "G0" + seekrate;
                    g += " X" + xpos + " Y" + ypos + "\n";
                // Else Cut move
                } else {
                    // we are in a non-first line so this is normal moving
                    // if the laser is not on, we need to turn it on
                    if (!isLaserOn) {
                        if (laseron) {
                            g += laseron
                            g += '\n'
                        } else {
                            // Nothing - most of the firmware used G0 = move, G1 = cut and doesnt need a laseron/laseroff command
                        };
                        isLaserOn = true;
                    }

                    // do normal feedrate move
                    var feedrate;
                    if (isFeedrateSpecifiedAlready) {
                    } else {
                        console.log('Cut Speed: ', cutSpeed);
                        if (cutSpeed) {
                            feedrate = " F" + cutSpeed;
                            isFeedrateSpecifiedAlready = true;
                        } else {
                            feedrate = "";
                        }
                    }
                    g += "G1" + feedrate;
                    g += " X" + xpos;
                    g += " Y" + ypos;
                    g += " S" + laserPwrVal + "\n";
                    var xpos = parseFloat(worldPt.x.toFixed(3));
                    var ypos = parseFloat(worldPt.y.toFixed(3));
                    subj_paths.push({
                        X: xpos,
                        Y: ypos
                    });
                }
            }

            // make feedrate have to get specified again on next line if there is one
            isFeedrateSpecifiedAlready = false;
            isLaserOn = false;
            // if (firmware.indexOf('Grbl') == 0) {
            if (laseroff) {
                g += laseroff
                g += '\n'
            } else {
                // Nothing - most of the firmware used G0 = move, G1 = cut and doesnt need a laseron/laseroff command
            }
        }
    });
    console.log("generated gcode. length:", g.length);
    isGcodeInRegeneratingState = false;
    return g;
};

addOperation = function(index, operation) {

  if (operation == "Laser (no offset)") {
    objectsInScene[index].userData.inflated = false;
    objectsInScene[index].userData.operation = operation;
  }

  if (operation == "Inside") {
    objectsInScene[index].userData.inflated = inflatePath(objectsInScene[index], -($("#tooldia").val()/2) );
    objectsInScene[index].userData.operation = operation;
  }

  if (operation == "Outside") {
    objectsInScene[index].userData.inflated = inflatePath(objectsInScene[index], ($("#tooldia").val()/2) );
    objectsInScene[index].userData.operation = operation;
  }

  if (operation == "Pocket") {
    objectsInScene[index].userData.inflated = pocketPath(objectsInScene[index], ($("#tooldia").val()/2) );
    objectsInScene[index].userData.operation = operation;
  }

  setTimeout(function(){ fillLayerTabs(); }, 100);

}

inflatePath = function(infobject, inflateVal) {
    if (typeof(inflateGrp) != 'undefined') {
        scene.remove(inflateGrp);
        inflateGrp = null;
    }
    if (inflateVal != 0) {
        console.log("user wants to inflate. val:", inflateVal);
        infobject.updateMatrix();
        var grp = infobject;
        var clipperPaths = [];
        grp.traverse(function(child) {
            console.log('Traverse: ', child)
            if (child.name == "inflatedGroup") {
                console.log("this is the inflated path from a previous run. ignore.");
                return;
            } else if (child.type == "Line") {
                // let's inflate the path for this line. it may not be closed
                // so we need to check that.
                var clipperArr = [];
                // Fix world Coordinates
                for (i = 0; i < child.geometry.vertices.length; i++) {
                    var localPt = child.geometry.vertices[i];
                    var worldPt = grp.localToWorld(localPt.clone());
                    var xpos = (parseFloat(worldPt.x.toFixed(3)));
                    var ypos = (parseFloat(worldPt.y.toFixed(3)));

                    clipperArr.push({
                        X: xpos,
                        Y: ypos
                    });
                }
                clipperPaths.push(clipperArr);
            } else if (child.type == "Points") {
                child.visible = false;
            } else {
                console.log("type of ", child.type, " being skipped");
            }
        });

        console.log("clipperPaths:", clipperPaths);

        // simplify this set of paths which is a very powerful Clipper call that figures out holes and path orientations
        var newClipperPaths = simplifyPolygons(clipperPaths);

        if (newClipperPaths.length < 1) {
            console.error("Clipper Simplification Failed!:");
            printLog('Clipper Simplification Failed!', errorcolor)
        }

        // get the inflated/deflated path
        var inflatedPaths = getInflatePath(newClipperPaths, inflateVal);
        inflateGrp = drawClipperPaths(inflatedPaths, 0xff00ff, 0.8, 0.01, 0, true, "inflatedGroup"); // (paths, color, opacity, z, zstep, isClosed, isAddDirHelper, name, inflateVal)
        inflateGrp.name = 'inflateGrp';
        inflateGrp.position = infobject.position;
        return inflateGrp
    }
};


pocketPath = function(infobject, inflateVal) {

    var pocketGrp = new THREE.Group();
    if (typeof(inflateGrp) != 'undefined') {
        scene.remove(inflateGrp);
        inflateGrp = null;
    }
    if (inflateVal != 0) {
        console.log("user wants to inflate. val:", inflateVal);
        infobject.updateMatrix();
        var grp = infobject;
        var clipperPaths = [];
        grp.traverse(function(child) {
            console.log('Traverse: ', child)
            if (child.name == "inflatedGroup") {
                console.log("this is the inflated path from a previous run. ignore.");
                return;
            } else if (child.type == "Line") {
                // let's inflate the path for this line. it may not be closed
                // so we need to check that.
                var clipperArr = [];
                // Fix world Coordinates
                for (i = 0; i < child.geometry.vertices.length; i++) {
                    var localPt = child.geometry.vertices[i];
                    var worldPt = grp.localToWorld(localPt.clone());
                    var xpos = (parseFloat(worldPt.x.toFixed(3)));
                    var ypos = (parseFloat(worldPt.y.toFixed(3)));

                    clipperArr.push({
                        X: xpos,
                        Y: ypos
                    });
                }
                clipperPaths.push(clipperArr);
            } else if (child.type == "Points") {
                child.visible = false;
            } else {
                console.log("type of ", child.type, " being skipped");
            }
        });

        console.log("clipperPaths:", clipperPaths);

        // simplify this set of paths which is a very powerful Clipper call that figures out holes and path orientations
        var newClipperPaths = simplifyPolygons(clipperPaths);

        if (newClipperPaths.length < 1) {
            console.error("Clipper Simplification Failed!:");
            printLog('Clipper Simplification Failed!', errorcolor)
        }

        // get the inflated/deflated path
        var run;
        var index = 1;
        for (i = 1; i < 100; i++) {  // Rather 100 than a while loop, just in case
          inflateValUsed = inflateVal * i;
          var inflatedPaths = getInflatePath(newClipperPaths, -inflateValUsed);
          inflateGrp = drawClipperPaths(inflatedPaths, 0xff00ff, 0.8, 0.01, 0, true, "inflatedGroup"); // (paths, color, opacity, z, zstep, isClosed, isAddDirHelper, name, inflateVal)
          if (inflateGrp.children.length) {
            inflateGrp.name = 'inflateGrp';
            inflateGrp.position = infobject.position;
            pocketGrp.add(inflateGrp)
          } else {
            console.log('Pocket already done after ' + i + ' iterations')
            break;
          }
        }
        return pocketGrp
    }
};


simplifyPolygons = function(paths) {
    console.log('Simplifying: ', paths)
    var scale = 10000;
    ClipperLib.JS.ScaleUpPaths(paths, scale);
    var newClipperPaths = ClipperLib.Clipper.SimplifyPolygons(paths, ClipperLib.PolyFillType.pftEvenOdd);
    console.log('Simplified: ', newClipperPaths)
    // scale back down
    ClipperLib.JS.ScaleDownPaths(newClipperPaths, scale);
    ClipperLib.JS.ScaleDownPaths(paths, scale);
    return newClipperPaths;
};

getInflatePath = function(paths, delta, joinType) {
    var scale = 10000;
    ClipperLib.JS.ScaleUpPaths(paths, scale);
    var miterLimit = 2;
    var arcTolerance = 10;
    joinType = joinType ? joinType : ClipperLib.JoinType.jtRound
    var co = new ClipperLib.ClipperOffset(miterLimit, arcTolerance);
    co.AddPaths(paths, joinType, ClipperLib.EndType.etClosedPolygon);
    //var delta = 0.0625; // 1/16 inch endmill
    var offsetted_paths = new ClipperLib.Paths();
    co.Execute(offsetted_paths, delta * scale);
    // scale back down
    ClipperLib.JS.ScaleDownPaths(offsetted_paths, scale);
    ClipperLib.JS.ScaleDownPaths(paths, scale);
    return offsetted_paths;
};

drawClipperPaths = function(paths, color, opacity, z, zstep, isClosed, name) {
    console.log("drawClipperPaths");

    var lineUnionMat = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: opacity,
    });

    if (z === undefined || z == null)
        z = 0;

    if (zstep === undefined || zstep == null)
        zstep = 0;

    if (isClosed === undefined || isClosed == null)
        isClosed = true;

    var group = new THREE.Object3D();
    if (name) group.name = name;

    for (var i = 0; i < paths.length; i++) {
        var lineUnionGeo = new THREE.Geometry();
        for (var j = 0; j < paths[i].length; j++) {
            var actualZ = z;
            if (zstep != 0) actualZ += zstep * j;
            lineUnionGeo.vertices.push(new THREE.Vector3(paths[i][j].X, paths[i][j].Y, actualZ));

        }
        // close it by connecting last point to 1st point
        if (isClosed) lineUnionGeo.vertices.push(new THREE.Vector3(paths[i][0].X, paths[i][0].Y, z));
        var lineUnion = new THREE.Line(lineUnionGeo, lineUnionMat);
        if (name) lineUnion.name = name;
        group.add(lineUnion);
    }
    return group;
};
